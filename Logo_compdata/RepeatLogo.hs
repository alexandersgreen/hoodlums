{-# LANGUAGE DeriveFunctor, TemplateHaskell, TypeOperators #-}
{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, FlexibleContexts #-} 
{-# LANGUAGE UndecidableInstances, IncoherentInstances, ScopedTypeVariables #-}

-- | This module contains the definition of our logo repetition command, along
-- with an instance for evaluation, and parsing.
module RepeatLogo where

import SVG
import Eval
import Parse

import Data.Comp
import Data.Comp.Derive
import Data.Comp.Show

import Control.Monad.State

import Text.ParserCombinators.Parsec
import Control.Applicative hiding ((<|>))

import Data.List

-- | The data-type representing a repetition command, automatically derives
-- an instance of the Functor type class. We also use compdata to derive
-- smart constructors.
data RepeatLogoF r = Repeat Integer [r]
 deriving (Functor, Eq, Show)

derive [makeEqF, makeShowF,smartConstructors] [''RepeatLogoF]

-- | A repetition command can be evaluated
instance Eval RepeatLogoF where
  evalAlg (Repeat n is) = do
   let ops = concat $ genericReplicate n is
   ss <- sequence ops
   return $ concat ss

-- | A repetition command can be generated by a parser. Note the type of the
-- dummy term passed to /terms/, in the definition of /terms'/, which enables
-- the repeated sequence to contain logo terms from a super-type of 
-- /RepeatLogoF/ that is itself parseable.
instance (RepeatLogoF :<: l, Functor l, Parse l l) => Parse RepeatLogoF l where
  parser _ = do
   let terms' :: Parser [Term l] = terms (dummy:: Term l) 
   iRepeat <$> (string "repeat" *> many1 space *> integer) <*> (many1 space *> char '[' *> terms' <* char ']')